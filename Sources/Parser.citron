// -*- mode: lemon; tab-width: 2; c-basic-offset: 2; -*-
// Part of the Carbon Language project, under the Apache License v2.0 with LLVM
// Exceptions. See /LICENSE for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

%class_name CarbonParser

%preface {
  /// Returns `first.site...last.site`
  fileprivate func ... <First: AST, Last: AST>(first: First, last: Last)
    -> SourceRegion
  {
    first.site...last.site
  }

  extension _CitronParserUnexpectedTokenError
    : CustomDebugStringConvertible
  {
    var debugDescription: String {
      "UnexpectedToken(token: \(token), tokenCode: \(tokenCode))"
    }
  }
}

%token_type Token

%nonterminal_type illegal_character Never
%nonterminal_type input {[TopLevelDeclaration]}
%nonterminal_type pattern Pattern
%nonterminal_type expression Expression
%nonterminal_type type_specifier Expression
%nonterminal_type member_designator MemberDesignator
%nonterminal_type tuple_literal {List<Expression>}
%nonterminal_type tuple_pattern TuplePattern
%nonterminal_type tuple_pattern_element_list {[TuplePattern.Element]}
%nonterminal_type match_clause MatchClause
%nonterminal_type match_clause_list MatchClauseList
%nonterminal_type statement Statement
%nonterminal_type statement_list {[Statement]}
%nonterminal_type return_type Expression
%nonterminal_type function_definition FunctionDefinition
%nonterminal_type function_declaration FunctionDefinition
%nonterminal_type binding_declaration Binding
%nonterminal_type member StructMemberDeclaration
%nonterminal_type member_list {[StructMemberDeclaration]}
%nonterminal_type alternative Alternative
%nonterminal_type alternative_list {[Alternative]}
%nonterminal_type top_level_declaration TopLevelDeclaration
%nonterminal_type declaration_list {[TopLevelDeclaration]}
%nonterminal_type identifier Identifier
%nonterminal_type argument_tuple {List<Expression>}
%nonterminal_type type_tuple {List<Expression>}
%nonterminal_type function_parameter_tuple TupleLiteral
%nonterminal_type function_parameter_list TupleLiteral
%nonterminal_type expression_list {[Expression]}
%nonterminal_type record_literal RecordLiteral
%nonterminal_type record_literal_element_list {[RecordLiteral.Element]}
%nonterminal_type record_literal_element {RecordLiteral.Element}

%nonterminal_type record_pattern RecordPattern
%nonterminal_type record_pattern_element_list {[RecordPattern.Element]}
%nonterminal_type record_pattern_tail {[RecordPattern.Element]}
%nonterminal_type record_pattern_element {RecordPattern.Element}

%nonassociative LEFT_CURLY_BRACE RIGHT_CURLY_BRACE.
%nonassociative COLON COMMA DBLARROW.
%left_associative OR AND.
%nonassociative EQUAL_EQUAL NOT.
%left_associative PLUS MINUS.
%left_associative PERIOD ARROW.
%nonassociative LEFT_PARENTHESIS RIGHT_PARENTHESIS.
%nonassociative LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET.
%right_associative ELSE.
%start_symbol input

input ::= declaration_list(d).      { d }
pattern ::= expression(e).          { .literal(e) }
pattern ::= tuple_pattern(t).       { .tuple(t) }
pattern ::= record_pattern(r).      { .record(r) }
pattern ::= expression(n) tuple_pattern(t).
  { .alternative(identity: n, payload: t) }

// identifier is just Identifier without the TokenID
identifier ::= Identifier(i).
  { Identifier(text: i.text, site: i.site) }
expression ::= identifier(i).
  { .name(i) }
expression ::= expression(t) member_designator(m).
  { .getField(target: t, fieldName: m, t...m) }
expression ::= expression(t)
  LEFT_SQUARE_BRACKET expression(i) RIGHT_SQUARE_BRACKET(b).
  { .index(target: t, offset: i, t...b) }
type_specifier ::= expression(t) COLON.
  {t}
expression ::= Integer_literal(i).
  { .integerLiteral(Int(i.text)!, i.site) }
expression ::= TRUE(t).
  { .booleanLiteral(true, t.site) }
expression ::= FALSE(t).
  { .booleanLiteral(false, t.site) }
expression ::= INT(t).
  { .intType(t.site) }
expression ::= BOOL(t).
  { .boolType(t.site) }
expression ::= TYPE(t).
  { .typeType(t.site) }
type_specifier ::= AUTO(t) COLON.
  { .autoType(t.site) }
expression ::= LEFT_PARENTHESIS expression(e) RIGHT_PARENTHESIS.
  { e }
expression ::= expression(l) EQUAL_EQUAL(op) expression(r).
  { .binaryOperator(operation: op, lhs: l, rhs: r, l...r)}
expression ::= expression(l) PLUS(op) expression(r).
  { .binaryOperator(operation: op, lhs: l, rhs: r, l...r)}
expression ::= expression(l) MINUS(op) expression(r).
  { .binaryOperator(operation: op, lhs: l, rhs: r, l...r)}
expression ::= expression(l) AND(op) expression(r).
  { .binaryOperator(operation: op, lhs: l, rhs: r, l...r)}
expression ::= expression(l) OR(op) expression(r).
  { .binaryOperator(operation: op, lhs: l, rhs: r, l...r)}
expression ::= NOT(op) expression(r).
  { .unaryOperator(operation: op, operand: r, op...r)}
expression ::= MINUS(op) expression(r).
  { .unaryOperator(operation: op, operand: r, op...r)}
expression ::= expression(f) argument_tuple(a).
  { .functionCall(callee: f, arguments: a, f...a)}
expression ::= expression(f) record_literal(a).
  { .structInitialization(type: f, fieldInitializers: a, f...a)}

argument_tuple ::= LEFT_PARENTHESIS(l) RIGHT_PARENTHESIS(r).
  { List([], l...r) }
argument_tuple ::= LEFT_PARENTHESIS(l) expression_list(a) RIGHT_PARENTHESIS(r).
  { List(a, l...r) }

type_tuple ::= LEFT_PARENTHESIS(l) RIGHT_PARENTHESIS(r).
  { List([], l...r) }
type_tuple ::= LEFT_PARENTHESIS(l) expression_list(a) RIGHT_PARENTHESIS(r).
  { List(a, l...r) }

expression_list ::= expression(e).
  { [e] }
expression_list ::= expression(e) COMMA expression_list(a).
  { [e] + a }

record_literal ::=
  LEFT_PARENTHESIS(l) record_literal_element_list(e) RIGHT_PARENTHESIS(r).
  { RecordLiteral(e, l...r) }
record_literal_element_list ::= record_literal_element(e).
  { [e] }
record_literal_element_list ::=
  record_literal_element(e) COMMA record_literal_element_list(l).
  { [e] + l }
record_literal_element ::= member_designator(m) EQUAL expression(e).
  { (fieldName: m, value: e) }

record_pattern ::=
  LEFT_PARENTHESIS(l) record_pattern_element_list(e) RIGHT_PARENTHESIS(r).
  { RecordPattern(e, l...r) }
record_pattern_element_list ::= record_pattern_element(e).
  { [e] }
record_pattern_element_list ::=
  record_literal_element(e) COMMA record_pattern_element_list(l).
  { [RecordPatternElement.literal(fieldName: e.fieldName, value: e.value)] + l }
record_pattern_element_list ::=
  record_pattern_element(e) COMMA record_pattern_tail(l).
  { [e] + l }
record_pattern_tail ::= record_literal_element_list.{}
record_pattern_tail ::= record_pattern_element_list.{}
record_pattern_element ::= member_designator EQUAL binding_declaration.{}

expression ::= FNTY(k) type_tuple(p) return_type(r).
  { .functionType(parameterTypes: p, returnType: r, k...r)}
member_designator ::= PERIOD(p) identifier(n).
  { MemberDesignator(text: n.text, site: p...n) }

expression ::= record_literal(r).
  { .recordLiteral(r) }
expression ::= tuple_literal(t).
  { .tupleLiteral(t) }
tuple_literal ::= LEFT_PARENTHESIS(l) RIGHT_PARENTHESIS(r).
  { List([], l...r) }
tuple_literal ::= LEFT_PARENTHESIS(l) expression(e) COMMA RIGHT_PARENTHESIS(r).
  { List([e], l...r) }
tuple_literal
  ::= LEFT_PARENTHESIS(l) expression(e) COMMA
      expression_list(t) RIGHT_PARENTHESIS(r).
  { List([e] + t, l...r) }

tuple_pattern ::= LEFT_PARENTHESIS(l) binding_declaration(e) COMMA RIGHT_PARENTHESIS(r).
  { TuplePattern([.binding(e)], l...r) }
tuple_pattern
  ::= LEFT_PARENTHESIS(l) binding_declaration(p) COMMA
      expression_list(t) RIGHT_PARENTHESIS(r).
  { TuplePattern([.binding(p)] + t.map {.literal($0)}, l...r) }
tuple_pattern
  ::= LEFT_PARENTHESIS(l) expression(p) COMMA
      tuple_pattern_element_list(t) RIGHT_PARENTHESIS(r).
  { TuplePattern([.literal(p)] + t, l...r) }
tuple_pattern
  ::= LEFT_PARENTHESIS(l) binding_declaration(p) COMMA
      tuple_pattern_element_list(t) RIGHT_PARENTHESIS(r).
  { TuplePattern([.binding(p)] + t, l...r) }

tuple_pattern_element_list ::= binding_declaration(e).
  { [.binding(e)] }
tuple_pattern_element_list ::= binding_declaration(e) COMMA expression_list(a).
  { [.binding(e)] + a.map { .literal($0) } }
tuple_pattern_element_list ::= expression(e) COMMA tuple_pattern_element_list(a).
  { [.literal(e)] + a }
tuple_pattern_element_list ::= binding_declaration(e) COMMA tuple_pattern_element_list(a).
  { [.binding(e)] + a }

match_clause ::= CASE(c) pattern(p) DBLARROW statement(s).
  { MatchClause(pattern: p, action: s, site: c...s) }
match_clause ::= DEFAULT(d) DBLARROW statement(s).
  { MatchClause(pattern: nil, action: s, site: d...s) }
match_clause_list ::= /* Empty */.
  { MatchClauseList([], .empty) }
match_clause_list ::= match_clause(c) match_clause_list(l).
  { MatchClauseList([c] + l, c...l) }
statement ::= expression(l) EQUAL expression(r) SEMICOLON(s).
  { .assignment(target: l, source: r, l...s) }
statement ::= VAR(v) pattern(p) EQUAL expression(e) SEMICOLON(s).
  { .patternBinding(pattern: p, initializer: e, v...s) }
statement ::= expression(e) SEMICOLON(s).
  { .expressionStatement(e, e...s) }
statement ::= IF(i) LEFT_PARENTHESIS expression(c) RIGHT_PARENTHESIS
  statement(t) ELSE statement(f).
  { .if(condition: c, thenClause: t, elseClause: f, i...f) }
statement ::= IF(i) LEFT_PARENTHESIS expression(c) RIGHT_PARENTHESIS
  statement(t).
  { .if(condition: c, thenClause: t, elseClause: nil, i...t) }
statement ::= WHILE(w) LEFT_PARENTHESIS expression(c) RIGHT_PARENTHESIS
  statement(b).
  { .while(condition: c, body: b, w...b) }
statement ::= BREAK(b) SEMICOLON(s).
  { .break(b...s) }
statement ::= CONTINUE(c) SEMICOLON(s).
  { .continue(c...s) }
statement ::= RETURN(r) expression(e) SEMICOLON(s).
  { .return(e, r...s) }
statement ::= LEFT_CURLY_BRACE(l) statement_list(s) RIGHT_CURLY_BRACE(r).
  { .block(s, l...r) }
statement ::= MATCH(m) LEFT_PARENTHESIS expression(e) RIGHT_PARENTHESIS
  LEFT_CURLY_BRACE match_clause_list(c) RIGHT_CURLY_BRACE(r).
  { .match(subject: e, clauses: c.elements, m...r) }
statement_list ::= /* Empty */.
  { [] }
statement_list ::= statement(s) statement_list(l).
  { [s] + l }
return_type ::= /* Empty */.
  { .tupleLiteral(List([], .empty)) }
return_type ::= ARROW(a) expression(e).
  { e }
function_definition
  ::= FN(f) identifier(n) function_parameter_tuple(p) return_type(t)
  LEFT_CURLY_BRACE(l) statement_list(b) RIGHT_CURLY_BRACE(r).
  {
    FunctionDefinition(
      name: n, parameterPattern: p, returnType: t,
      body: .block(b, l...r), site: f...r)
  }
function_definition
  ::= FN(f) identifier(n)
  function_parameter_tuple(p) DBLARROW expression(b) SEMICOLON(s).
  {
    FunctionDefinition(
      name: n, parameterPattern: p, returnType: .autoType(.empty),
      body: .return(b, b.site), site: f...s)
  }
function_declaration
  ::= FN(f) identifier(n)
  function_parameter_tuple(p) return_type(r) SEMICOLON(s).
  {
    FunctionDefinition(
      name: n, parameterPattern: p, returnType: r,
      body: nil, site: f...s)
  }

function_parameter_tuple ::= LEFT_PARENTHESIS(l) RIGHT_PARENTHESIS(r).
  { TupleLiteral([], l...r) }
function_parameter_tuple
  ::= LEFT_PARENTHESIS(l) function_parameter_list(p) RIGHT_PARENTHESIS(r).
  { TupleLiteral(p.elements, l...r) }
function_parameter_list ::= binding_declaration(v).
  { TupleLiteral([.init(name: v.name, value: v.type)], v.type...v.name) }
function_parameter_list
  ::= binding_declaration(v) COMMA function_parameter_list(p).
  {
    TupleLiteral([.init(name: v.name, value: v.type)] + p.elements, v.type...p)
  }

binding_declaration ::= type_specifier(t) identifier(n).
  { (type: t, name: n) }
member ::= VAR(v) binding_declaration(d) SEMICOLON(s).
  { StructMemberDeclaration(name: d.name, type: d.type, site: v...s) }
member_list ::= /* Empty */.
  { [] }
member_list ::= member(m) member_list(l).
  { [m] + l }
alternative ::= identifier(n) type_tuple(p).
  { Alternative(name: n, payload: p, site: n...p) }
alternative ::= identifier(n).
  { Alternative(name: n, payload: .init([], .empty), site: n.site) }
alternative_list ::= /* Empty */.
  { [] }
alternative_list ::= alternative(a).
  { [a] }
alternative_list ::= alternative(a) COMMA alternative_list(l).
  { [a] + l }
top_level_declaration ::= function_definition(f).
  { .function(f) }
top_level_declaration ::= function_declaration(f).
  { .function(f) }
top_level_declaration ::=
  STRUCT(s) identifier(n) LEFT_CURLY_BRACE member_list(m) RIGHT_CURLY_BRACE(r).
  { .struct(.init(name: n, members: m, site: s...r)) }
top_level_declaration ::= CHOICE(c) identifier(n)
  LEFT_CURLY_BRACE alternative_list(l) RIGHT_CURLY_BRACE(r).
  { .choice(.init(name: n, alternatives: l, site: c...r)) }
top_level_declaration
  ::= VAR(v) binding_declaration(d) EQUAL expression(i) SEMICOLON(s).
  { .variable(.init(type: d.type, name: d.name, initializer: i, site: v...s)) }
declaration_list ::= /* Empty */.
  { [] }
declaration_list ::= top_level_declaration(d) declaration_list(l).
  { [d] + l }
illegal_character ::= ILLEGAL_CHARACTER
