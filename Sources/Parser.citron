// -*- mode: lemon; tab-width: 2; c-basic-offset: 2; -*-
// Part of the Carbon Language project, under the Apache License v2.0 with LLVM
// Exceptions. See /LICENSE for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

%class_name CarbonParser

%preface {
  /// Returns the region from the beginning of `first` to the end of `last`,
  /// unless one of `first` or `last` has an empty site, in which case the
  /// site of the other one is returned.
  ///
  /// - Requires first or last is empty, or `first.site.fileName ==
  ///   last.site.fileName && first.site.span.lowerBound
  ///   < last.site.span.upperBound`.
  fileprivate func ... <First, Last>(first: AST<First>, last: AST<Last>)
    -> SourceRegion
  {
    if first.site.span.isEmpty { return last.site }
    if last.site.span.isEmpty { return first.site }

    assert(first.site.fileName == last.site.fileName)
    return SourceRegion(
      fileName: first.site.fileName,
      first.site.span.lowerBound..<last.site.span.upperBound)
  }

  fileprivate extension TupleLiteral_ {
    /// Creates an instance from a (perhaps-too-eagerly parsed) field list.
    init(_ source: FieldList) {
      self = source.body.fields.map {
        TupleLiteralElement(name: $0.body.first, value: $0.body.second)
      }
    }
  }
}

%token_type Token

%nonterminal_type illegal_character Never
%nonterminal_type input {[Declaration]}
%nonterminal_type pattern Expression
%nonterminal_type expression Expression
%nonterminal_type member_designator MemberDesignator
%nonterminal_type paren_expression Expression
%nonterminal_type tuple TupleLiteral
%nonterminal_type field Field
%nonterminal_type field_list FieldList
%nonterminal_type match_clause MatchClause
%nonterminal_type match_clause_list MatchClauseList
%nonterminal_type statement Statement
%nonterminal_type optional_else {Statement?}
%nonterminal_type statement_list {[Statement]}
%nonterminal_type return_type Expression
%nonterminal_type function_definition FunctionDefinition
%nonterminal_type function_declaration FunctionDefinition
%nonterminal_type variable_declaration VariableDeclaration
%nonterminal_type member VariableDeclaration
%nonterminal_type member_list {[VariableDeclaration]}
%nonterminal_type alternative Alternative
%nonterminal_type alternative_list {[Alternative]}
%nonterminal_type declaration Declaration
%nonterminal_type declaration_list {[Declaration]}
%nonterminal_type identifier Identifier

%nonassociative LEFT_CURLY_BRACE RIGHT_CURLY_BRACE.
%nonassociative COLON COMMA DBLARROW.
%left_associative OR AND.
%nonassociative EQUAL_EQUAL NOT.
%left_associative PLUS MINUS.
%left_associative PERIOD ARROW.
%nonassociative LEFT_PARENTHESIS RIGHT_PARENTHESIS.
%nonassociative LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET.
%start_symbol input

input ::= declaration_list(d). {d}
pattern ::= expression(e).     {e}

// identifier is just Identifier without the TokenID
identifier ::= Identifier(i).
  { AST(i.body.text, i.site) }
expression ::= identifier(i).
  { AST(.variable(i), i.site) }
expression ::= expression(t) member_designator(m).
  { AST(.getField(target: t, fieldName: m), t...m) }
expression ::= expression(t)
  LEFT_SQUARE_BRACKET expression(i) RIGHT_SQUARE_BRACKET(b).
  { AST(.index(target: t, offset: i), t...b) }
expression ::= expression(t) COLON identifier(i).
  { AST(.patternVariable(name: i, type: t), t...i) }
expression ::= Integer_literal(i).
  { AST(.integerLiteral(Int(i.body.text)!), i.site) }
expression ::= TRUE(t).
  { AST(.booleanLiteral(true), t.site) }
expression ::= FALSE(t).
  { AST(.booleanLiteral(false), t.site) }
expression ::= INT(t).
  { AST(.intType, t.site) }
expression ::= BOOL(t).
  { AST(.boolType, t.site) }
expression ::= TYPE(t).
  { AST(.typeType, t.site) }
expression ::= AUTO(t).
  { AST(.autoType, t.site) }
expression ::= paren_expression(x).
  { x }
expression ::= expression(l) EQUAL_EQUAL(op) expression(r).
  {AST(.binaryOperator(operation: op, lhs: l, rhs: r), l...r)}
expression ::= expression(l) PLUS(op) expression(r).
  {AST(.binaryOperator(operation: op, lhs: l, rhs: r), l...r)}
expression ::= expression(l) MINUS(op) expression(r).
  {AST(.binaryOperator(operation: op, lhs: l, rhs: r), l...r)}
expression ::= expression(l) AND(op) expression(r).
  {AST(.binaryOperator(operation: op, lhs: l, rhs: r), l...r)}
expression ::= expression(l) OR(op) expression(r).
  {AST(.binaryOperator(operation: op, lhs: l, rhs: r), l...r)}
expression ::= NOT(op) expression(r).
  {AST(.unaryOperator(operation: op, operand: r), op...r)}
expression ::= MINUS(op) expression(r).
  {AST(.unaryOperator(operation: op, operand: r), op...r)}
expression ::= expression(f) tuple(a).
  {AST(.functionCall(callee: f, arguments: a), f...a)}
expression ::= FNTY(k) tuple(p) return_type(r).
  {AST(.functionType(parameterTypes: p, returnType: r), k...r)}
member_designator ::= PERIOD(p) identifier(n).
  { AST(n.body, p...n) }
paren_expression ::= LEFT_PARENTHESIS(l) field_list(f) RIGHT_PARENTHESIS(r).
  {
    if !f.body.hasExplicitComma && f.body.fields.count == 1 {
      let firstField = f.body.fields.first!.body
      if firstField.first == nil { return AST(firstField.second.body, l...r) }
    }
    return AST(.tupleLiteral(TupleLiteral_(f)), l...r)
  }

tuple ::= LEFT_PARENTHESIS(l) field_list(f) RIGHT_PARENTHESIS(r).
  { AST(TupleLiteral_(f), l...r) }

field ::= pattern(p).
  { AST(Field_(first: nil,  second: p), p.site) }

field ::= member_designator(m) EQUAL pattern(p).
  { AST(Field_(first: m, second: p), m...p) }

field_list ::= /* Empty */.
  { AST(FieldList_(fields: [], hasExplicitComma: false), .empty) }
field_list ::= field(f).
  { AST(.init(fields: [f], hasExplicitComma: false), f.site) }
field_list ::= field(f) COMMA(c) field_list(l).
  {
    AST(
      FieldList_(
          fields: [f] + l.body.fields,
          hasExplicitComma: l.body.hasExplicitComma),
     l.body.fields.isEmpty ? f...c : f...l)
  }
match_clause ::= CASE(c) pattern(p) DBLARROW statement(s).
  { AST(.init(pattern: p, action: s), c...s) }
match_clause ::= DEFAULT(d) DBLARROW statement(s).
  { AST(.init(pattern: nil, action: s), d...s) }
match_clause_list ::= /* Empty */.
  { AST([], .empty) }
match_clause_list ::= match_clause(c) match_clause_list(l).
  { AST([c] + l.body, c...l) }
statement ::= expression(l) EQUAL expression(r) SEMICOLON(s).
  { AST(.assignment(target: l, source: r), l...s) }
statement ::= VAR(v) pattern(p) EQUAL expression(e) SEMICOLON(s).
  { AST(.variableDefinition(pattern: p, initializer: e), v...s) }
statement ::= expression(e) SEMICOLON(s).
  { AST(.expressionStatement(e), e...s) }
statement ::= IF(i) LEFT_PARENTHESIS expression(c) RIGHT_PARENTHESIS
  statement(s) optional_else(e).
  { AST(.if(condition: c, thenClause: s, elseClause: e), e.map {i...$0} ?? i...s) }
statement ::= WHILE(w) LEFT_PARENTHESIS expression(c) RIGHT_PARENTHESIS
  statement(b).
  { AST(.while(condition: c, body: b), w...b) }
statement ::= BREAK(b) SEMICOLON(s).
  { AST(.break, b...s) }
statement ::= CONTINUE(c) SEMICOLON(s).
  { AST(.continue, c...s) }
statement ::= RETURN(r) expression(e) SEMICOLON(s).
  { AST(.return(e), r...s) }
statement ::= LEFT_CURLY_BRACE(l) statement_list(s) RIGHT_CURLY_BRACE(r).
  { AST(.block(s), l...r) }
statement ::= MATCH(m) LEFT_PARENTHESIS expression(e) RIGHT_PARENTHESIS
  LEFT_CURLY_BRACE match_clause_list(c) RIGHT_CURLY_BRACE(r).
  { AST(.match(subject: e, clauses: c.body), m...r) }
optional_else ::= /* Empty */.
  { nil }
optional_else ::= ELSE(e) statement(s).
  { AST(s.body, e...s) }
statement_list ::= /* Empty */.
  { [] }
statement_list ::= statement(s) statement_list(l).
  { [s] + l }
return_type ::= /* Empty */.
  { AST(.tupleLiteral([]), .empty) }
return_type ::= ARROW(a) expression(e).
  { AST(e.body, a...e) }
function_definition ::= FN(f) identifier(n) tuple(p) return_type(t)
  LEFT_CURLY_BRACE(l) statement_list(b) RIGHT_CURLY_BRACE(r).
  {
    FunctionDefinition(
      .init(
        name: n, parameterPattern: p, returnType: t,
        body: Statement(.block(b), l...r)),
      f...r)
  }
function_definition
  ::= FN(f) identifier(n) tuple(p) DBLARROW expression(b) SEMICOLON(s).
  {
    FunctionDefinition(
      .init(
        name: n, parameterPattern: p, returnType: Expression(.autoType, .empty),
        body: Statement(.return(b), b.site)),
      f...s)
  }
function_declaration
  ::= FN(f) identifier(n) tuple(p) return_type(r) SEMICOLON(s).
  {
    FunctionDefinition(
      .init(
        name: n, parameterPattern: p, returnType: r,
        body: nil),
      f...s)
  }
variable_declaration ::= expression(t) COLON identifier(n).
  { VariableDeclaration(.init(name: n, type: t), t...n) }
member ::= VAR(v) variable_declaration(d) SEMICOLON(s).
  { AST(d.body, v...s) }
member_list ::= /* Empty */.
  { [] }
member_list ::= member(m) member_list(l).
  { [m] + l }
alternative ::= identifier(n) tuple(p).
  { Alternative(.init(name: n, payload: p), n...p) }
alternative ::= identifier(n).
  { Alternative(.init(name: n, payload: .init([], .empty)), n.site) }
alternative_list ::= /* Empty */.
  { [] }
alternative_list ::= alternative(a).
  { [a] }
alternative_list ::= alternative(a) COMMA alternative_list(l).
  { [a] + l }
declaration ::= function_definition(f).
  { AST(.function(f), f.site) }
declaration ::= function_declaration(f).
  { AST(.function(f), f.site) }
declaration ::=
  STRUCT(s) identifier(n) LEFT_CURLY_BRACE member_list(m) RIGHT_CURLY_BRACE(r).
  { AST(.struct(StructDefinition(name: n, members: m)), s...r) }
declaration ::= CHOICE(c) identifier(n)
  LEFT_CURLY_BRACE alternative_list(l) RIGHT_CURLY_BRACE(r).
  { AST(.choice(ChoiceDefinition(name: n, alternatives: l)), c...r) }
declaration ::= VAR(v) variable_declaration(d) EQUAL expression(i) SEMICOLON(s).
  { AST(.variable(name: d.body.name, type: d.body.type, initializer: i), v...s) }
declaration_list ::= /* Empty */.
  { [] }
declaration_list ::= declaration(d) declaration_list(l).
  { [d] + l }
illegal_character ::= ILLEGAL_CHARACTER
