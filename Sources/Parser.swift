// This file is automatically generated by Citron version 2.0.
//
// The parser class defined below conforms to the CitronParser protocol
// defined in CitronParser.swift. 
// 
// The authors of Citron disclaim copyright to the source code in this file.

// Preface


  fileprivate func ... <First, Last>(first: AST<First>, last: AST<Last>)
    -> SourceLocation
  {
    if first.location.span.isEmpty { return last.location }
    if last.location.span.isEmpty { return first.location }
    
    assert(first.location.fileName == last.location.fileName)
    return SourceLocation(
      fileName: first.location.fileName,
      first.location.span.lowerBound..<last.location.span.upperBound)
  }

  fileprivate extension Array where Element == Field {
    func asTupleLiteral_() -> TupleLiteral_ {
      map { (name: $0.body.0, value: $0.body.1) }
    }
  }


// Parser class

class CarbonParser: CitronParser {

    // Types

    typealias CitronSymbolNumber = UInt8
    typealias CitronStateNumber = UInt8
    typealias CitronRuleNumber = UInt8

    enum CitronTokenCode: CitronSymbolNumber {
      case LEFT_CURLY_BRACE               =   1
      case RIGHT_CURLY_BRACE              =   2
      case COLON                          =   3
      case COMMA                          =   4
      case DBLARROW                       =   5
      case OR                             =   6
      case AND                            =   7
      case EQUAL_EQUAL                    =   8
      case NOT                            =   9
      case PLUS                           =  10
      case MINUS                          =  11
      case PERIOD                         =  12
      case ARROW                          =  13
      case LEFT_PARENTHESIS               =  14
      case RIGHT_PARENTHESIS              =  15
      case LEFT_SQUARE_BRACKET            =  16
      case RIGHT_SQUARE_BRACKET           =  17
      case IDENTIFIER                     =  18
      case Identifier                     =  19
      case Integer_literal                =  20
      case TRUE                           =  21
      case FALSE                          =  22
      case INT                            =  23
      case BOOL                           =  24
      case TYPE                           =  25
      case AUTO                           =  26
      case FNTY                           =  27
      case EQUAL                          =  28
      case CASE                           =  29
      case DEFAULT                        =  30
      case SEMICOLON                      =  31
      case VAR                            =  32
      case IF                             =  33
      case WHILE                          =  34
      case BREAK                          =  35
      case CONTINUE                       =  36
      case RETURN                         =  37
      case MATCH                          =  38
      case ELSE                           =  39
      case FN                             =  40
      case STRUCT                         =  41
      case CHOICE                         =  42
      case ILLEGAL_CHARACTER              =  43
    }

    enum CitronNonTerminalCode: CitronSymbolNumber {
      case illegal_character              =  44
      case input                          =  45
      case pattern                        =  46
      case expression                     =  47
      case member_designator              =  48
      case paren_expression               =  49
      case tuple                          =  50
      case field                          =  51
      case field_list                     =  52
      case match_clause                   =  53
      case match_clause_list              =  54
      case statement                      =  55
      case optional_else                  =  56
      case statement_list                 =  57
      case return_type                    =  58
      case function_definition            =  59
      case function_declaration           =  60
      case variable_declaration           =  61
      case member                         =  62
      case member_list                    =  63
      case alternative                    =  64
      case alternative_list               =  65
      case declaration                    =  66
      case declaration_list               =  67
    }

    enum CitronSymbolCode : RawRepresentable, Equatable {
        case token(CitronTokenCode)
        case nonterminal(CitronNonTerminalCode)
        case endOfInput

        init(_ token: CitronTokenCode) { self = .token(token) }
        init(_ nonterminal: CitronNonTerminalCode) { self = .nonterminal(nonterminal) }
        init(rawValue: CitronSymbolNumber) {
            if (rawValue == 0) {
                self = .endOfInput
            } else if (rawValue < 44) {
                self = .token(CitronTokenCode(rawValue: rawValue)!)
            } else if (rawValue < 68) {
                self = .nonterminal(CitronNonTerminalCode(rawValue: rawValue)!)
            } else {
                fatalError()
            }
        }

        typealias RawValue = CitronSymbolNumber
        var rawValue: CitronSymbolNumber {
            switch (self) {
            case .token(let t): return t.rawValue
            case .nonterminal(let nt): return nt.rawValue
            case .endOfInput: return 0
            }
        }
    }

    typealias CitronToken = AST<Token>

    enum CitronSymbol {
        case yyBaseOfStack
        case yy0(CitronToken)
        case yy1(VariableDeclaration)
        case yy4(Alternative)
        case yy9([VariableDeclaration])
        case yy48(TupleLiteral)
        case yy49(FieldList)
        case yy50(Statement)
        case yy56([Alternative])
        case yy57(Never)
        case yy71(MatchClause)
        case yy87(Declaration)
        case yy95([Declaration])
        case yy97(Expression)
        case yy98(Field)
        case yy102([Statement])
        case yy103(MatchClauseList)
        case yy117(MemberDesignator)
        case yy128(FunctionDefinition)
        case yy133(Statement?)

        func typeErasedContent() -> Any {
            switch (self) {
            case .yyBaseOfStack: fatalError()
            case .yy0(let value): return value as Any
            case .yy1(let value): return value as Any
            case .yy4(let value): return value as Any
            case .yy9(let value): return value as Any
            case .yy48(let value): return value as Any
            case .yy49(let value): return value as Any
            case .yy50(let value): return value as Any
            case .yy56(let value): return value as Any
            case .yy57(let value): return value as Any
            case .yy71(let value): return value as Any
            case .yy87(let value): return value as Any
            case .yy95(let value): return value as Any
            case .yy97(let value): return value as Any
            case .yy98(let value): return value as Any
            case .yy102(let value): return value as Any
            case .yy103(let value): return value as Any
            case .yy117(let value): return value as Any
            case .yy128(let value): return value as Any
            case .yy133(let value): return value as Any
            }
        }
    }

    typealias CitronResult = [Declaration]

    // Counts

    let yyNumberOfSymbols: Int = 68
    let yyNumberOfStates: Int = 99

    // Action tables

    let yyLookaheadAction: [(CitronSymbolNumber, CitronParsingAction)] = [
/*   0 */  ( 1, .SH( 5)), (46, .RD(26)), (47, .SH(46)), (48, .SH(93)), (49, .RD(13)),
/*   5 */  (19, .SH(62)), (51, .SH(92)), (52, .RD(30)), ( 9, .SH(28)), (47, .SH(36)),
/*  10 */  (11, .SH(27)), (49, .RD(13)), (28, .RD(54)), (14, .SH( 2)), (47, .SH(45)),
/*  15 */  (31, .RD(54)), (49, .RD(13)), (18, .SR( 2)), (58, .SH(68)), (20, .SR( 6)),
/*  20 */  (21, .SR( 7)), (22, .SR( 8)), (23, .SR( 9)), (24, .SR(10)), (25, .SR(11)),
/*  25 */  (26, .SR(12)), (27, .SH(65)), (47, .SH(37)), (61, .SH(69)), (49, .RD(13)),
/*  30 */  (32, .SH(13)), (32, .SH(16)), (33, .SH(89)), (34, .SH(88)), (35, .SH(87)),
/*  35 */  (36, .SH(86)), (37, .SH(21)), (38, .SH(84)), (40, .SH(97)), (41, .SH(78)),
/*  40 */  (42, .SH(73)), ( 9, .SH(28)), (32, .SH(14)), (11, .SH(27)), (12, .SH(95)),
/*  45 */  (14, .SH( 3)), (14, .SH( 2)), (47, .SH(45)), (39, .SH(11)), (49, .RD(13)),
/*  50 */  (18, .SR( 2)), (50, .RD(58)), (20, .SR( 6)), (21, .SR( 7)), (22, .SR( 8)),
/*  55 */  (23, .SR( 9)), (24, .SR(10)), (25, .SR(11)), (26, .SR(12)), (27, .SH(65)),
/*  60 */  ( 9, .SH(28)), (61, .SH(75)), (11, .SH(27)), (46, .SH(82)), (47, .SH(46)),
/*  65 */  (14, .SH( 2)), (49, .RD(13)), (46, .SH(90)), (47, .SH(46)), (18, .SR( 2)),
/*  70 */  (49, .RD(13)), (20, .SR( 6)), (21, .SR( 7)), (22, .SR( 8)), (23, .SR( 9)),
/*  75 */  (24, .SR(10)), (25, .SR(11)), (26, .SR(12)), (27, .SH(65)), ( 3, .SH(96)),
/*  80 */  (53, .SH(54)), (54, .RD(34)), ( 6, .SH(29)), ( 7, .SH(30)), ( 8, .SH(33)),
/*  85 */  (56, .RD(38)), (10, .SH(32)), (11, .SH(31)), (12, .SH(95)), (47, .SH(35)),
/*  90 */  (14, .SH( 3)), (49, .RD(13)), (16, .SH(34)), (46, .RD(26)), (47, .SH(46)),
/*  95 */  (48, .SH(93)), (49, .RD(13)), (55, .RD(32)), (51, .SH(92)), (52, .SH(94)),
/* 100 */  (46, .RD(26)), (47, .SH(46)), (48, .SH(93)), (49, .RD(13)), (28, .SH(25)),
/* 105 */  (51, .SH(92)), (52, .SH(91)), (31, .SR(37)), ( 3, .SH(96)), (29, .SH(15)),
/* 110 */  (30, .SH(81)), ( 6, .SH(29)), ( 7, .SH(30)), ( 8, .SH(33)), ( 5, .SH(19)),
/* 115 */  (10, .SH(32)), (11, .SH(31)), (12, .SH(95)), (58, .RD(22)), (14, .SH( 3)),
/* 120 */  ( 3, .SH(96)), (16, .SH(34)), (13, .SH(26)), ( 6, .SH(29)), ( 7, .SH(30)),
/* 125 */  ( 8, .SH(33)), (13, .SH(26)), (10, .SH(32)), (11, .SH(31)), (12, .SH(95)),
/* 130 */  ( 2, .SR(66)), (14, .SH( 3)), (45, .ACCEPT),   (16, .SH(34)), (53, .SH(54)),
/* 135 */  (54, .SH(80)), (31, .SR(67)), ( 8, .ERROR ),   (50, .SH(64)), (10, .SH(32)),
/* 140 */  (11, .SH(31)), (12, .SH(95)), (47, .SH(35)), (14, .SH( 3)), (49, .RD(13)),
/* 145 */  (16, .SH(34)), (59, .RD(63)), (60, .RD(64)), (31, .SR(52)), (47, .SH(38)),
/* 150 */  (55, .RD(31)), (49, .RD(13)), ( 3, .SH(96)), (66, .SH( 7)), (67, .SH(98)),
/* 155 */  ( 6, .SH(29)), ( 7, .SH(30)), ( 8, .SH(33)), (50, .SH(61)), (10, .SH(32)),
/* 160 */  (11, .SH(31)), (12, .SH(95)), (28, .SH(18)), (14, .SH( 3)), (15, .SH(83)),
/* 165 */  (16, .SH(34)), (48, .RD( 3)), ( 3, .SH(96)), (50, .RD(21)), ( 4, .SH(57)),
/* 170 */  ( 6, .SH(29)), ( 7, .SH(30)), ( 8, .SH(33)), ( 1, .SH(58)), (10, .SH(32)),
/* 175 */  (11, .SH(31)), (12, .SH(95)), (19, .SH(72)), (14, .SH( 3)), ( 3, .SH(96)),
/* 180 */  (16, .SH(34)), ( 1, .SH( 6)), ( 6, .SH(29)), ( 7, .SH(30)), ( 8, .SH(33)),
/* 185 */  ( 2, .SR(65)), (10, .SH(32)), (11, .SH(31)), (12, .SH(95)), (19, .SH(67)),
/* 190 */  (14, .SH( 3)), (15, .SH(10)), (16, .SH(34)), (31, .SR(55)), ( 3, .SH(96)),
/* 195 */  (31, .SR(42)), ( 1, .SH(60)), ( 6, .SH(29)), ( 7, .SH(30)), ( 8, .SH(33)),
/* 200 */  (19, .SH(77)), (10, .SH(32)), (11, .SH(31)), (12, .SH(95)), ( 2, .SR(51)),
/* 205 */  (14, .SH( 3)), (15, .SH(12)), (16, .SH(34)), (47, .SH(39)), ( 3, .SH(96)),
/* 210 */  (49, .RD(13)), (31, .SR(53)), ( 6, .SH(29)), ( 7, .SH(30)), ( 8, .SH(33)),
/* 215 */  ( 2, .SR(44)), (10, .SH(32)), (11, .SH(31)), (12, .SH(95)), ( 5, .SH( 8)),
/* 220 */  (14, .SH( 3)), ( 3, .SH(96)), (16, .SH(34)), (14, .SH(20)), ( 6, .SH(29)),
/* 225 */  ( 7, .SH(30)), ( 8, .SH(33)), ( 5, .SH( 9)), (10, .SH(32)), (11, .SH(31)),
/* 230 */  (12, .SH(95)), (47, .SH(35)), (14, .SH( 3)), (49, .RD(13)), (16, .SH(34)),
/* 235 */  (64, .SH(71)), (65, .RD(62)), (31, .SR(36)), ( 8, .SH(33)), (55, .RD(39)),
/* 240 */  (10, .SH(32)), (11, .SH(31)), (12, .SH(95)), (47, .SH(35)), (14, .SH( 3)),
/* 245 */  (49, .RD(13)), (16, .SH(34)), (59, .RD(63)), (60, .RD(64)), (31, .SR(35)),
/* 250 */  (47, .SH(40)), (55, .RD(46)), (49, .RD(13)), ( 3, .SH(96)), (66, .SH( 7)),
/* 255 */  (67, .RD(69)), ( 6, .SH(29)), ( 7, .SH(30)), ( 8, .SH(33)), ( 1, .SH(55)),
/* 260 */  (10, .SH(32)), (11, .SH(31)), (12, .SH(95)), ( 2, .SR(43)), (14, .SH( 3)),
/* 265 */  ( 3, .SH(76)), (16, .SH(34)), (17, .SR( 4)), ( 6, .SH(29)), ( 7, .SH(30)),
/* 270 */  ( 8, .SH(33)), (31, .SR(41)), (10, .SH(32)), (11, .SH(31)), (12, .SH(95)),
/* 275 */  (31, .SR(40)), (14, .SH( 3)), ( 3, .SH(96)), (16, .SH(34)), (14, .SH(22)),
/* 280 */  ( 6, .SH(29)), ( 7, .SH(30)), ( 8, .SH(33)), (11, .SH(24)), (10, .SH(32)),
/* 285 */  (11, .SH(31)), (12, .SH(95)), (19, .SR(23)), (14, .SH( 3)), (47, .SH(35)),
/* 290 */  (16, .SH(34)), (49, .RD(13)), (47, .SH(35)), (47, .SH(41)), (49, .RD(13)),
/* 295 */  (49, .RD(13)), (47, .SH(35)), (55, .SH( 4)), (49, .RD(13)), (57, .RD(48)),
/* 300 */  (55, .SH( 4)), (47, .SH(35)), (57, .SH(85)), (49, .RD(13)), (55, .SH(63)),
/* 305 */  (46, .RD(27)), (47, .SH(46)), (14, .SH(23)), (49, .RD(13)), (55, .SH( 4)),
/* 310 */  (12, .SH(95)), (57, .SH(79)), (14, .SH( 3)), (47, .SH(42)), (16, .SH(34)),
/* 315 */  (49, .RD(13)), (47, .SH(43)), (47, .SH(56)), (49, .RD(13)), (49, .RD(13)),
/* 320 */  (47, .SH(51)), (14, .SH( 3)), (49, .RD(13)), (16, .SH(34)), (47, .SH(47)),
/* 325 */  (47, .SH(48)), (49, .RD(13)), (49, .RD(13)), (47, .SH(49)), (47, .SH(52)),
/* 330 */  (49, .RD(13)), (49, .RD(13)), (47, .SH(53)), (47, .SH(50)), (49, .RD(13)),
/* 335 */  (49, .RD(13)), (47, .SH(44)), (15, .SR(25)), (49, .RD(13)), (64, .SH(71)),
/* 340 */  (65, .SH(70)), (62, .SH(59)), (63, .RD(57)), ( 4, .SH( 1)), (28, .SH(17)),
/* 345 */  (62, .SH(59)), (63, .SH(74)), (15, .SR(24)), (19, .SR( 5)), (19, .SH(66)),
/* 350 */  ( 0, .RD( 0)),
    ]

    let yyShiftUseDefault: Int = 351
    let yyShiftOffsetMin: Int = -16
    let yyShiftOffsetMax: Int = 350
    let yyShiftOffset: [Int] = [
        /*     0 */    -2,   32,   32,   32,   -1,   -1,   -1,   -2,   -1,   -1,
        /*    10 */    -1,   -1,   -1,   51,   51,   51,   51,   51,   51,   51,
        /*    20 */    51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
        /*    30 */    51,   51,   51,   51,   51,   76,  105,  117,  149,  164,
        /*    40 */   176,  191,  206,  218,  250,  262,  274,  129,  230,  230,
        /*    50 */   129,  298,  298,  298,   80,   80,  307,  -14,  -14,   10,
        /*    60 */    10,  109,   31,    9,  113,   31,   31,  -16,  180,  134,
        /*    70 */   128,  165,  172,  158,  183,  162,  170,  195,  181,  202,
        /*    80 */   213,  214,  222,  258,  209,  261,  240,  244,  265,  293,
        /*    90 */   272,  322,  339,  316,  332,  268,  329,  330,  350,
    ]

    let yyReduceUseDefault: Int = -46
    let yyReduceOffsetMin: Int =   -45
    let yyReduceOffsetMax: Int =   289
    let yyReduceOffset: [Int] = [
        /*     0 */    87,  -45,   47,   54,  242,  245,  254,  188,   42,   95,
        /*    10 */   184,  196,  249,  -33,    0,   17,   21,  259,  -38,  -20,
        /*    20 */   102,  161,  203,  246,  266,  269,  270,  273,  277,  278,
        /*    30 */   281,  282,  285,  286,  289,  118,  118,  118,  118,  118,
        /*    40 */   118,  118,  118,  118,  118,  118,  118,  118,  118,  118,
        /*    50 */   118,  118,  118,  118,   27,   81,  118,  171,  275,  279,
        /*    60 */   283,  -40,    1,   29,   60,   88,  108,
    ]

    let yyDefaultAction: [CitronParsingAction] = [
  /*     0 */  .RD(68), .RD(28), .RD(28), .RD(28), .RD(47),
  /*     5 */  .RD(47), .RD(47), .RD(68), .ERROR , .ERROR ,
  /*    10 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    15 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    20 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    25 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    30 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    35 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    40 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    45 */  .ERROR , .RD( 1), .RD(19), .RD(18), .RD(17),
  /*    50 */  .RD(14), .RD(20), .RD(16), .RD(15), .RD(33),
  /*    55 */  .RD(33), .RD(50), .RD(60), .RD(60), .RD(56),
  /*    60 */  .RD(56), .RD(49), .RD(59), .RD(45), .RD(49),
  /*    65 */  .ERROR , .ERROR , .RD( 5), .ERROR , .ERROR ,
  /*    70 */  .ERROR , .RD(61), .ERROR , .ERROR , .ERROR ,
  /*    75 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    80 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    85 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*    90 */  .ERROR , .ERROR , .RD(29), .ERROR , .ERROR ,
  /*    95 */  .ERROR , .ERROR , .ERROR , .ERROR ,
    ]

    // Fallback

    let yyHasFallback: Bool = false
    let yyFallback: [CitronSymbolNumber] = []

    // Wildcard

    let yyWildcard: CitronSymbolNumber? = nil

    // Rules

    let yyRuleInfo: [(lhs: CitronSymbolNumber, nrhs: UInt)] = [
        (lhs: 45, nrhs: 1),
        (lhs: 46, nrhs: 1),
        (lhs: 47, nrhs: 1),
        (lhs: 47, nrhs: 2),
        (lhs: 47, nrhs: 4),
        (lhs: 47, nrhs: 3),
        (lhs: 47, nrhs: 1),
        (lhs: 47, nrhs: 1),
        (lhs: 47, nrhs: 1),
        (lhs: 47, nrhs: 1),
        (lhs: 47, nrhs: 1),
        (lhs: 47, nrhs: 1),
        (lhs: 47, nrhs: 1),
        (lhs: 47, nrhs: 1),
        (lhs: 47, nrhs: 3),
        (lhs: 47, nrhs: 3),
        (lhs: 47, nrhs: 3),
        (lhs: 47, nrhs: 3),
        (lhs: 47, nrhs: 3),
        (lhs: 47, nrhs: 2),
        (lhs: 47, nrhs: 2),
        (lhs: 47, nrhs: 2),
        (lhs: 47, nrhs: 3),
        (lhs: 48, nrhs: 2),
        (lhs: 49, nrhs: 3),
        (lhs: 50, nrhs: 3),
        (lhs: 51, nrhs: 1),
        (lhs: 51, nrhs: 3),
        (lhs: 52, nrhs: 0),
        (lhs: 52, nrhs: 1),
        (lhs: 52, nrhs: 3),
        (lhs: 53, nrhs: 4),
        (lhs: 53, nrhs: 3),
        (lhs: 54, nrhs: 0),
        (lhs: 54, nrhs: 2),
        (lhs: 55, nrhs: 4),
        (lhs: 55, nrhs: 5),
        (lhs: 55, nrhs: 2),
        (lhs: 55, nrhs: 6),
        (lhs: 55, nrhs: 5),
        (lhs: 55, nrhs: 2),
        (lhs: 55, nrhs: 2),
        (lhs: 55, nrhs: 3),
        (lhs: 55, nrhs: 3),
        (lhs: 55, nrhs: 7),
        (lhs: 56, nrhs: 0),
        (lhs: 56, nrhs: 2),
        (lhs: 57, nrhs: 0),
        (lhs: 57, nrhs: 2),
        (lhs: 58, nrhs: 0),
        (lhs: 58, nrhs: 2),
        (lhs: 59, nrhs: 7),
        (lhs: 59, nrhs: 6),
        (lhs: 60, nrhs: 5),
        (lhs: 61, nrhs: 3),
        (lhs: 62, nrhs: 3),
        (lhs: 63, nrhs: 0),
        (lhs: 63, nrhs: 2),
        (lhs: 64, nrhs: 2),
        (lhs: 64, nrhs: 1),
        (lhs: 65, nrhs: 0),
        (lhs: 65, nrhs: 1),
        (lhs: 65, nrhs: 3),
        (lhs: 66, nrhs: 1),
        (lhs: 66, nrhs: 1),
        (lhs: 66, nrhs: 5),
        (lhs: 66, nrhs: 5),
        (lhs: 66, nrhs: 5),
        (lhs: 67, nrhs: 0),
        (lhs: 67, nrhs: 2),
    ]

    // Stack

    var yyStack: [(stateOrRule: CitronStateOrRule , symbolCode: CitronSymbolNumber, symbol: CitronSymbol)]  = [
        (stateOrRule: .state(0), symbolCode: 0, symbol: .yyBaseOfStack)
    ]
    var maxStackSize: Int? = nil
    var maxAttainedStackSize: Int = 0

    // Tracing

    var isTracingEnabled: Bool = false
    var isTracingPrintsSymbolValues: Bool = false
    var isTracingPrintsTokenValues: Bool = false
    let yySymbolName: [String] = [
    /*  0 */ "$",
    /*  1 */ "LEFT_CURLY_BRACE",
    /*  2 */ "RIGHT_CURLY_BRACE",
    /*  3 */ "COLON",
    /*  4 */ "COMMA",
    /*  5 */ "DBLARROW",
    /*  6 */ "OR",
    /*  7 */ "AND",
    /*  8 */ "EQUAL_EQUAL",
    /*  9 */ "NOT",
    /* 10 */ "PLUS",
    /* 11 */ "MINUS",
    /* 12 */ "PERIOD",
    /* 13 */ "ARROW",
    /* 14 */ "LEFT_PARENTHESIS",
    /* 15 */ "RIGHT_PARENTHESIS",
    /* 16 */ "LEFT_SQUARE_BRACKET",
    /* 17 */ "RIGHT_SQUARE_BRACKET",
    /* 18 */ "IDENTIFIER",
    /* 19 */ "Identifier",
    /* 20 */ "Integer_literal",
    /* 21 */ "TRUE",
    /* 22 */ "FALSE",
    /* 23 */ "INT",
    /* 24 */ "BOOL",
    /* 25 */ "TYPE",
    /* 26 */ "AUTO",
    /* 27 */ "FNTY",
    /* 28 */ "EQUAL",
    /* 29 */ "CASE",
    /* 30 */ "DEFAULT",
    /* 31 */ "SEMICOLON",
    /* 32 */ "VAR",
    /* 33 */ "IF",
    /* 34 */ "WHILE",
    /* 35 */ "BREAK",
    /* 36 */ "CONTINUE",
    /* 37 */ "RETURN",
    /* 38 */ "MATCH",
    /* 39 */ "ELSE",
    /* 40 */ "FN",
    /* 41 */ "STRUCT",
    /* 42 */ "CHOICE",
    /* 43 */ "ILLEGAL_CHARACTER",
    /* 44 */ "illegal_character",
    /* 45 */ "input",
    /* 46 */ "pattern",
    /* 47 */ "expression",
    /* 48 */ "member_designator",
    /* 49 */ "paren_expression",
    /* 50 */ "tuple",
    /* 51 */ "field",
    /* 52 */ "field_list",
    /* 53 */ "match_clause",
    /* 54 */ "match_clause_list",
    /* 55 */ "statement",
    /* 56 */ "optional_else",
    /* 57 */ "statement_list",
    /* 58 */ "return_type",
    /* 59 */ "function_definition",
    /* 60 */ "function_declaration",
    /* 61 */ "variable_declaration",
    /* 62 */ "member",
    /* 63 */ "member_list",
    /* 64 */ "alternative",
    /* 65 */ "alternative_list",
    /* 66 */ "declaration",
    /* 67 */ "declaration_list",
    ]
    let yyRuleText: [String] = [
        /*   0 */ "input ::= declaration_list(d)",
        /*   1 */ "pattern ::= expression(e)",
        /*   2 */ "expression ::= IDENTIFIER(i)",
        /*   3 */ "expression ::= expression(t) member_designator(m)",
        /*   4 */ "expression ::= expression(t) LEFT_SQUARE_BRACKET expression(i) RIGHT_SQUARE_BRACKET(b)",
        /*   5 */ "expression ::= expression(t) COLON Identifier(i)",
        /*   6 */ "expression ::= Integer_literal(i)",
        /*   7 */ "expression ::= TRUE(t)",
        /*   8 */ "expression ::= FALSE(t)",
        /*   9 */ "expression ::= INT(t)",
        /*  10 */ "expression ::= BOOL(t)",
        /*  11 */ "expression ::= TYPE(t)",
        /*  12 */ "expression ::= AUTO(t)",
        /*  13 */ "expression ::= paren_expression(x)",
        /*  14 */ "expression ::= expression(l) EQUAL_EQUAL(op) expression(r)",
        /*  15 */ "expression ::= expression(l) PLUS(op) expression(r)",
        /*  16 */ "expression ::= expression(l) MINUS(op) expression(r)",
        /*  17 */ "expression ::= expression(l) AND(op) expression(r)",
        /*  18 */ "expression ::= expression(l) OR(op) expression(r)",
        /*  19 */ "expression ::= NOT(op) expression(r)",
        /*  20 */ "expression ::= MINUS(op) expression(r)",
        /*  21 */ "expression ::= expression(f) tuple(a)",
        /*  22 */ "expression ::= FNTY(k) tuple(p) return_type(r)",
        /*  23 */ "member_designator ::= PERIOD(p) Identifier(n)",
        /*  24 */ "paren_expression ::= LEFT_PARENTHESIS(l) field_list(f) RIGHT_PARENTHESIS(r)",
        /*  25 */ "tuple ::= LEFT_PARENTHESIS(l) field_list(f) RIGHT_PARENTHESIS(r)",
        /*  26 */ "field ::= pattern(p)",
        /*  27 */ "field ::= member_designator(m) EQUAL pattern(p)",
        /*  28 */ "field_list ::=",
        /*  29 */ "field_list ::= field(f)",
        /*  30 */ "field_list ::= field(f) COMMA(c) field_list(l)",
        /*  31 */ "match_clause ::= CASE(c) pattern(p) DBLARROW statement(s)",
        /*  32 */ "match_clause ::= DEFAULT(d) DBLARROW statement(s)",
        /*  33 */ "match_clause_list ::=",
        /*  34 */ "match_clause_list ::= match_clause(c) match_clause_list(l)",
        /*  35 */ "statement ::= expression(l) EQUAL expression(r) SEMICOLON(s)",
        /*  36 */ "statement ::= VAR(v) pattern(p) MINUS expression(e) SEMICOLON(s)",
        /*  37 */ "statement ::= expression(e) SEMICOLON(s)",
        /*  38 */ "statement ::= IF(i) LEFT_PARENTHESIS expression(c) RIGHT_PARENTHESIS statement(s) optional_else(e)",
        /*  39 */ "statement ::= WHILE(w) LEFT_PARENTHESIS expression(c) RIGHT_PARENTHESIS statement(b)",
        /*  40 */ "statement ::= BREAK(b) SEMICOLON(s)",
        /*  41 */ "statement ::= CONTINUE(c) SEMICOLON(s)",
        /*  42 */ "statement ::= RETURN(r) expression(e) SEMICOLON(s)",
        /*  43 */ "statement ::= LEFT_CURLY_BRACE(l) statement_list(s) RIGHT_CURLY_BRACE(r)",
        /*  44 */ "statement ::= MATCH(m) LEFT_PARENTHESIS expression(e) RIGHT_PARENTHESIS LEFT_CURLY_BRACE match_clause_list(c) RIGHT_CURLY_BRACE(r)",
        /*  45 */ "optional_else ::=",
        /*  46 */ "optional_else ::= ELSE(e) statement(s)",
        /*  47 */ "statement_list ::=",
        /*  48 */ "statement_list ::= statement(s) statement_list(l)",
        /*  49 */ "return_type ::=",
        /*  50 */ "return_type ::= ARROW(a) expression(e)",
        /*  51 */ "function_definition ::= FN(f) Identifier(n) tuple(p) return_type(t) LEFT_CURLY_BRACE(l) statement_list(b) RIGHT_CURLY_BRACE(r)",
        /*  52 */ "function_definition ::= FN(f) Identifier(n) tuple(p) DBLARROW expression(b) SEMICOLON(s)",
        /*  53 */ "function_declaration ::= FN(f) Identifier(n) tuple(p) return_type(r) SEMICOLON(s)",
        /*  54 */ "variable_declaration ::= expression(t) COLON Identifier(n)",
        /*  55 */ "member ::= VAR(v) variable_declaration(d) SEMICOLON(s)",
        /*  56 */ "member_list ::=",
        /*  57 */ "member_list ::= member(m) member_list(l)",
        /*  58 */ "alternative ::= Identifier(n) tuple(p)",
        /*  59 */ "alternative ::= Identifier(n)",
        /*  60 */ "alternative_list ::=",
        /*  61 */ "alternative_list ::= alternative(a)",
        /*  62 */ "alternative_list ::= alternative(a) COMMA alternative_list(l)",
        /*  63 */ "declaration ::= function_definition(f)",
        /*  64 */ "declaration ::= function_declaration(f)",
        /*  65 */ "declaration ::= STRUCT(s) Identifier(n) LEFT_CURLY_BRACE member_list(m) RIGHT_CURLY_BRACE(r)",
        /*  66 */ "declaration ::= CHOICE(c) Identifier(n) LEFT_CURLY_BRACE alternative_list(l) RIGHT_CURLY_BRACE(r)",
        /*  67 */ "declaration ::= VAR(v) variable_declaration(d) EQUAL expression(i) SEMICOLON(s)",
        /*  68 */ "declaration_list ::=",
        /*  69 */ "declaration_list ::= declaration(d) declaration_list(l)",
    ]

    // Function definitions

    func yyTokenToSymbol(_ token: CitronToken) -> CitronSymbol {
        return .yy0(token)
    }

    func yyInvokeCodeBlockForRule(ruleNumber: CitronRuleNumber) throws -> CitronSymbol {
        switch (ruleNumber) {
        case 0: /* input ::= declaration_list(d) */
            func codeBlockForRule00(d: [Declaration]) throws -> [Declaration] {d }
            if case .yy95(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy95(try codeBlockForRule00(d: d))
            }
        case 1: /* pattern ::= expression(e) */
            func codeBlockForRule01(e: Expression) throws -> Expression {e }
            if case .yy97(let e) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule01(e: e))
            }
        case 2: /* expression ::= IDENTIFIER(i) */
            func codeBlockForRule02(i: AST<Token>) throws -> Expression { (.variable(i), i.location)  }
            if case .yy0(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule02(i: i))
            }
        case 3: /* expression ::= expression(t) member_designator(m) */
            func codeBlockForRule03(t: Expression, m: MemberDesignator) throws -> Expression { (.getField(target: t, fieldName: m), location: t...m)  }
            if case .yy97(let t) = yySymbolOnStack(distanceFromTop: 1),
               case .yy117(let m) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule03(t: t, m: m))
            }
        case 4: /* expression ::= expression(t) LEFT_SQUARE_BRACKET expression(i) RIGHT_SQUARE_BRACKET(b) */
            func codeBlockForRule04(t: Expression, i: Expression, b: AST<Token>) throws -> Expression { (.index(target: t, offset: i), t...b)  }
            if case .yy97(let t) = yySymbolOnStack(distanceFromTop: 3),
               case .yy97(let i) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule04(t: t, i: i, b: b))
            }
        case 5: /* expression ::= expression(t) COLON Identifier(i) */
            func codeBlockForRule05(t: Expression, i: AST<Token>) throws -> Expression { (.patternVariable(name: i, type: t), t...i)  }
            if case .yy97(let t) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule05(t: t, i: i))
            }
        case 6: /* expression ::= Integer_literal(i) */
            func codeBlockForRule06(i: AST<Token>) throws -> Expression { (.integerLiteral(Int(i.body.text)!), i.location)  }
            if case .yy0(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule06(i: i))
            }
        case 7: /* expression ::= TRUE(t) */
            func codeBlockForRule07(t: AST<Token>) throws -> Expression { (.booleanLiteral(true), t.location)  }
            if case .yy0(let t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule07(t: t))
            }
        case 8: /* expression ::= FALSE(t) */
            func codeBlockForRule08(t: AST<Token>) throws -> Expression { (.booleanLiteral(false), t.location)  }
            if case .yy0(let t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule08(t: t))
            }
        case 9: /* expression ::= INT(t) */
            func codeBlockForRule09(t: AST<Token>) throws -> Expression { (.intType, t.location)  }
            if case .yy0(let t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule09(t: t))
            }
        case 10: /* expression ::= BOOL(t) */
            func codeBlockForRule10(t: AST<Token>) throws -> Expression { (.boolType, t.location)  }
            if case .yy0(let t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule10(t: t))
            }
        case 11: /* expression ::= TYPE(t) */
            func codeBlockForRule11(t: AST<Token>) throws -> Expression { (.typeType, t.location)  }
            if case .yy0(let t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule11(t: t))
            }
        case 12: /* expression ::= AUTO(t) */
            func codeBlockForRule12(t: AST<Token>) throws -> Expression { (.autoType, t.location)  }
            if case .yy0(let t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule12(t: t))
            }
        case 13: /* expression ::= paren_expression(x) */
            func codeBlockForRule13(x: Expression) throws -> Expression { x  }
            if case .yy97(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule13(x: x))
            }
        case 14: /* expression ::= expression(l) EQUAL_EQUAL(op) expression(r) */
            func codeBlockForRule14(l: Expression, op: AST<Token>, r: Expression) throws -> Expression {(.binaryOperator(operation: op.body, lhs: l, rhs: r), l...r) }
            if case .yy97(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let op) = yySymbolOnStack(distanceFromTop: 1),
               case .yy97(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule14(l: l, op: op, r: r))
            }
        case 15: /* expression ::= expression(l) PLUS(op) expression(r) */
            func codeBlockForRule15(l: Expression, op: AST<Token>, r: Expression) throws -> Expression {(.binaryOperator(operation: op.body, lhs: l, rhs: r), l...r) }
            if case .yy97(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let op) = yySymbolOnStack(distanceFromTop: 1),
               case .yy97(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule15(l: l, op: op, r: r))
            }
        case 16: /* expression ::= expression(l) MINUS(op) expression(r) */
            func codeBlockForRule16(l: Expression, op: AST<Token>, r: Expression) throws -> Expression {(.binaryOperator(operation: op.body, lhs: l, rhs: r), l...r) }
            if case .yy97(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let op) = yySymbolOnStack(distanceFromTop: 1),
               case .yy97(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule16(l: l, op: op, r: r))
            }
        case 17: /* expression ::= expression(l) AND(op) expression(r) */
            func codeBlockForRule17(l: Expression, op: AST<Token>, r: Expression) throws -> Expression {(.binaryOperator(operation: op.body, lhs: l, rhs: r), l...r) }
            if case .yy97(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let op) = yySymbolOnStack(distanceFromTop: 1),
               case .yy97(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule17(l: l, op: op, r: r))
            }
        case 18: /* expression ::= expression(l) OR(op) expression(r) */
            func codeBlockForRule18(l: Expression, op: AST<Token>, r: Expression) throws -> Expression {(.binaryOperator(operation: op.body, lhs: l, rhs: r), l...r) }
            if case .yy97(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let op) = yySymbolOnStack(distanceFromTop: 1),
               case .yy97(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule18(l: l, op: op, r: r))
            }
        case 19: /* expression ::= NOT(op) expression(r) */
            func codeBlockForRule19(op: AST<Token>, r: Expression) throws -> Expression {(.unaryOperator(operation: op.body, operand: r), op...r) }
            if case .yy0(let op) = yySymbolOnStack(distanceFromTop: 1),
               case .yy97(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule19(op: op, r: r))
            }
        case 20: /* expression ::= MINUS(op) expression(r) */
            func codeBlockForRule20(op: AST<Token>, r: Expression) throws -> Expression {(.unaryOperator(operation: op.body, operand: r), op...r) }
            if case .yy0(let op) = yySymbolOnStack(distanceFromTop: 1),
               case .yy97(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule20(op: op, r: r))
            }
        case 21: /* expression ::= expression(f) tuple(a) */
            func codeBlockForRule21(f: Expression, a: TupleLiteral) throws -> Expression {(.functionCall(callee: f, arguments: a), f...a) }
            if case .yy97(let f) = yySymbolOnStack(distanceFromTop: 1),
               case .yy48(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule21(f: f, a: a))
            }
        case 22: /* expression ::= FNTY(k) tuple(p) return_type(r) */
            func codeBlockForRule22(k: AST<Token>, p: TupleLiteral, r: Expression) throws -> Expression {(.functionType(parameterTypes: p, returnType: r), k...r) }
            if case .yy0(let k) = yySymbolOnStack(distanceFromTop: 2),
               case .yy48(let p) = yySymbolOnStack(distanceFromTop: 1),
               case .yy97(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule22(k: k, p: p, r: r))
            }
        case 23: /* member_designator ::= PERIOD(p) Identifier(n) */
            func codeBlockForRule23(p: AST<Token>, n: AST<Token>) throws -> MemberDesignator { (n.body, p...n)  }
            if case .yy0(let p) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let n) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy117(try codeBlockForRule23(p: p, n: n))
            }
        case 24: /* paren_expression ::= LEFT_PARENTHESIS(l) field_list(f) RIGHT_PARENTHESIS(r) */
            func codeBlockForRule24(l: AST<Token>, f: FieldList, r: AST<Token>) throws -> Expression {
    if !f.body.hasExplicitComma && f.body.fields.count == 1 {
      let firstField = f.body.fields.first!.body
      if firstField.0 == nil { return (firstField.1.body, l...r) }
    }
    return (.tupleLiteral(f.body.fields.asTupleLiteral_()), l...r)
   }
            if case .yy0(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy49(let f) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule24(l: l, f: f, r: r))
            }
        case 25: /* tuple ::= LEFT_PARENTHESIS(l) field_list(f) RIGHT_PARENTHESIS(r) */
            func codeBlockForRule25(l: AST<Token>, f: FieldList, r: AST<Token>) throws -> TupleLiteral { (f.body.fields.asTupleLiteral_(), l...r)  }
            if case .yy0(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy49(let f) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy48(try codeBlockForRule25(l: l, f: f, r: r))
            }
        case 26: /* field ::= pattern(p) */
            func codeBlockForRule26(p: Expression) throws -> Field { ((nil,  p), p.location)  }
            if case .yy97(let p) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy98(try codeBlockForRule26(p: p))
            }
        case 27: /* field ::= member_designator(m) EQUAL pattern(p) */
            func codeBlockForRule27(m: MemberDesignator, p: Expression) throws -> Field { ((m, p), m...p)  }
            if case .yy117(let m) = yySymbolOnStack(distanceFromTop: 2),
               case .yy97(let p) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy98(try codeBlockForRule27(m: m, p: p))
            }
        case 28: /* field_list ::= */
            func codeBlockForRule28() throws -> FieldList { (([], hasExplicitComma: false), .empty)  }
            return .yy49(try codeBlockForRule28())
        case 29: /* field_list ::= field(f) */
            func codeBlockForRule29(f: Field) throws -> FieldList { (([f], hasExplicitComma: false), f.location)  }
            if case .yy98(let f) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy49(try codeBlockForRule29(f: f))
            }
        case 30: /* field_list ::= field(f) COMMA(c) field_list(l) */
            func codeBlockForRule30(f: Field, c: AST<Token>, l: FieldList) throws -> FieldList {
    (([f] + l.body.fields, l.body.hasExplicitComma), 
     location: l.body.fields.isEmpty ? f...c : f...l) 
   }
            if case .yy98(let f) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let c) = yySymbolOnStack(distanceFromTop: 1),
               case .yy49(let l) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy49(try codeBlockForRule30(f: f, c: c, l: l))
            }
        case 31: /* match_clause ::= CASE(c) pattern(p) DBLARROW statement(s) */
            func codeBlockForRule31(c: AST<Token>, p: Expression, s: Statement) throws -> MatchClause { ((pattern: p, action: s), c...s)  }
            if case .yy0(let c) = yySymbolOnStack(distanceFromTop: 3),
               case .yy97(let p) = yySymbolOnStack(distanceFromTop: 2),
               case .yy50(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy71(try codeBlockForRule31(c: c, p: p, s: s))
            }
        case 32: /* match_clause ::= DEFAULT(d) DBLARROW statement(s) */
            func codeBlockForRule32(d: AST<Token>, s: Statement) throws -> MatchClause { ((pattern: nil, action: s), d...s)  }
            if case .yy0(let d) = yySymbolOnStack(distanceFromTop: 2),
               case .yy50(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy71(try codeBlockForRule32(d: d, s: s))
            }
        case 33: /* match_clause_list ::= */
            func codeBlockForRule33() throws -> MatchClauseList { ([], .empty)  }
            return .yy103(try codeBlockForRule33())
        case 34: /* match_clause_list ::= match_clause(c) match_clause_list(l) */
            func codeBlockForRule34(c: MatchClause, l: MatchClauseList) throws -> MatchClauseList { ([c] + l.body, c...l)  }
            if case .yy71(let c) = yySymbolOnStack(distanceFromTop: 1),
               case .yy103(let l) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy103(try codeBlockForRule34(c: c, l: l))
            }
        case 35: /* statement ::= expression(l) EQUAL expression(r) SEMICOLON(s) */
            func codeBlockForRule35(l: Expression, r: Expression, s: AST<Token>) throws -> Statement { (.assignment(target: l, source: r), l...s)  }
            if case .yy97(let l) = yySymbolOnStack(distanceFromTop: 3),
               case .yy97(let r) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy50(try codeBlockForRule35(l: l, r: r, s: s))
            }
        case 36: /* statement ::= VAR(v) pattern(p) MINUS expression(e) SEMICOLON(s) */
            func codeBlockForRule36(v: AST<Token>, p: Expression, e: Expression, s: AST<Token>) throws -> Statement { (.variableDefinition(pattern: p, initializer: e), v...s)  }
            if case .yy0(let v) = yySymbolOnStack(distanceFromTop: 4),
               case .yy97(let p) = yySymbolOnStack(distanceFromTop: 3),
               case .yy97(let e) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy50(try codeBlockForRule36(v: v, p: p, e: e, s: s))
            }
        case 37: /* statement ::= expression(e) SEMICOLON(s) */
            func codeBlockForRule37(e: Expression, s: AST<Token>) throws -> Statement { (.expressionStatement(e), e...s)  }
            if case .yy97(let e) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy50(try codeBlockForRule37(e: e, s: s))
            }
        case 38: /* statement ::= IF(i) LEFT_PARENTHESIS expression(c) RIGHT_PARENTHESIS statement(s) optional_else(e) */
            func codeBlockForRule38(i: AST<Token>, c: Expression, s: Statement, e: Statement?) throws -> Statement { (.if(condition: c, thenClause: s, elseClause: e), e.map {i...$0} ?? i...s)  }
            if case .yy0(let i) = yySymbolOnStack(distanceFromTop: 5),
               case .yy97(let c) = yySymbolOnStack(distanceFromTop: 3),
               case .yy50(let s) = yySymbolOnStack(distanceFromTop: 1),
               case .yy133(let e) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy50(try codeBlockForRule38(i: i, c: c, s: s, e: e))
            }
        case 39: /* statement ::= WHILE(w) LEFT_PARENTHESIS expression(c) RIGHT_PARENTHESIS statement(b) */
            func codeBlockForRule39(w: AST<Token>, c: Expression, b: Statement) throws -> Statement { (.while(condition: c, body: b), w...b)  }
            if case .yy0(let w) = yySymbolOnStack(distanceFromTop: 4),
               case .yy97(let c) = yySymbolOnStack(distanceFromTop: 2),
               case .yy50(let b) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy50(try codeBlockForRule39(w: w, c: c, b: b))
            }
        case 40: /* statement ::= BREAK(b) SEMICOLON(s) */
            func codeBlockForRule40(b: AST<Token>, s: AST<Token>) throws -> Statement { (.break, b...s)  }
            if case .yy0(let b) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy50(try codeBlockForRule40(b: b, s: s))
            }
        case 41: /* statement ::= CONTINUE(c) SEMICOLON(s) */
            func codeBlockForRule41(c: AST<Token>, s: AST<Token>) throws -> Statement { (.continue, c...s)  }
            if case .yy0(let c) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy50(try codeBlockForRule41(c: c, s: s))
            }
        case 42: /* statement ::= RETURN(r) expression(e) SEMICOLON(s) */
            func codeBlockForRule42(r: AST<Token>, e: Expression, s: AST<Token>) throws -> Statement { (.return(e), r...s)  }
            if case .yy0(let r) = yySymbolOnStack(distanceFromTop: 2),
               case .yy97(let e) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy50(try codeBlockForRule42(r: r, e: e, s: s))
            }
        case 43: /* statement ::= LEFT_CURLY_BRACE(l) statement_list(s) RIGHT_CURLY_BRACE(r) */
            func codeBlockForRule43(l: AST<Token>, s: [Statement], r: AST<Token>) throws -> Statement { (.block(s), l...r)  }
            if case .yy0(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy102(let s) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy50(try codeBlockForRule43(l: l, s: s, r: r))
            }
        case 44: /* statement ::= MATCH(m) LEFT_PARENTHESIS expression(e) RIGHT_PARENTHESIS LEFT_CURLY_BRACE match_clause_list(c) RIGHT_CURLY_BRACE(r) */
            func codeBlockForRule44(m: AST<Token>, e: Expression, c: MatchClauseList, r: AST<Token>) throws -> Statement { (.match(subject: e, clauses: c.body), m...r)  }
            if case .yy0(let m) = yySymbolOnStack(distanceFromTop: 6),
               case .yy97(let e) = yySymbolOnStack(distanceFromTop: 4),
               case .yy103(let c) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy50(try codeBlockForRule44(m: m, e: e, c: c, r: r))
            }
        case 45: /* optional_else ::= */
            func codeBlockForRule45() throws -> Statement? { nil  }
            return .yy133(try codeBlockForRule45())
        case 46: /* optional_else ::= ELSE(e) statement(s) */
            func codeBlockForRule46(e: AST<Token>, s: Statement) throws -> Statement? { (s.body, e...s)  }
            if case .yy0(let e) = yySymbolOnStack(distanceFromTop: 1),
               case .yy50(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy133(try codeBlockForRule46(e: e, s: s))
            }
        case 47: /* statement_list ::= */
            func codeBlockForRule47() throws -> [Statement] { []  }
            return .yy102(try codeBlockForRule47())
        case 48: /* statement_list ::= statement(s) statement_list(l) */
            func codeBlockForRule48(s: Statement, l: [Statement]) throws -> [Statement] { [s] + l  }
            if case .yy50(let s) = yySymbolOnStack(distanceFromTop: 1),
               case .yy102(let l) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy102(try codeBlockForRule48(s: s, l: l))
            }
        case 49: /* return_type ::= */
            func codeBlockForRule49() throws -> Expression { (.tupleLiteral([]), .empty)  }
            return .yy97(try codeBlockForRule49())
        case 50: /* return_type ::= ARROW(a) expression(e) */
            func codeBlockForRule50(a: AST<Token>, e: Expression) throws -> Expression { (e.body, a...e)  }
            if case .yy0(let a) = yySymbolOnStack(distanceFromTop: 1),
               case .yy97(let e) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy97(try codeBlockForRule50(a: a, e: e))
            }
        case 51: /* function_definition ::= FN(f) Identifier(n) tuple(p) return_type(t) LEFT_CURLY_BRACE(l) statement_list(b) RIGHT_CURLY_BRACE(r) */
            func codeBlockForRule51(f: AST<Token>, n: AST<Token>, p: TupleLiteral, t: Expression, l: AST<Token>, b: [Statement], r: AST<Token>) throws -> FunctionDefinition {
    (
      FunctionDefinition_(
        name: n, parameterPattern: p, returnType: t, body: (.block(b), l...r)),
      f...r)
   }
            if case .yy0(let f) = yySymbolOnStack(distanceFromTop: 6),
               case .yy0(let n) = yySymbolOnStack(distanceFromTop: 5),
               case .yy48(let p) = yySymbolOnStack(distanceFromTop: 4),
               case .yy97(let t) = yySymbolOnStack(distanceFromTop: 3),
               case .yy0(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy102(let b) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy128(try codeBlockForRule51(f: f, n: n, p: p, t: t, l: l, b: b, r: r))
            }
        case 52: /* function_definition ::= FN(f) Identifier(n) tuple(p) DBLARROW expression(b) SEMICOLON(s) */
            func codeBlockForRule52(f: AST<Token>, n: AST<Token>, p: TupleLiteral, b: Expression, s: AST<Token>) throws -> FunctionDefinition {
    (
      FunctionDefinition_(
        name: n, parameterPattern: p, returnType: (.autoType, .empty),
        body: (Statement_.return(b), b.location)),
      f...s)
   }
            if case .yy0(let f) = yySymbolOnStack(distanceFromTop: 5),
               case .yy0(let n) = yySymbolOnStack(distanceFromTop: 4),
               case .yy48(let p) = yySymbolOnStack(distanceFromTop: 3),
               case .yy97(let b) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy128(try codeBlockForRule52(f: f, n: n, p: p, b: b, s: s))
            }
        case 53: /* function_declaration ::= FN(f) Identifier(n) tuple(p) return_type(r) SEMICOLON(s) */
            func codeBlockForRule53(f: AST<Token>, n: AST<Token>, p: TupleLiteral, r: Expression, s: AST<Token>) throws -> FunctionDefinition {
    (
      FunctionDefinition_(
        name: n, parameterPattern: p, returnType: r,
        body: nil),
      f...s)
   }
            if case .yy0(let f) = yySymbolOnStack(distanceFromTop: 4),
               case .yy0(let n) = yySymbolOnStack(distanceFromTop: 3),
               case .yy48(let p) = yySymbolOnStack(distanceFromTop: 2),
               case .yy97(let r) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy128(try codeBlockForRule53(f: f, n: n, p: p, r: r, s: s))
            }
        case 54: /* variable_declaration ::= expression(t) COLON Identifier(n) */
            func codeBlockForRule54(t: Expression, n: AST<Token>) throws -> VariableDeclaration { ((name: n, type: t), t...n)  }
            if case .yy97(let t) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let n) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy1(try codeBlockForRule54(t: t, n: n))
            }
        case 55: /* member ::= VAR(v) variable_declaration(d) SEMICOLON(s) */
            func codeBlockForRule55(v: AST<Token>, d: VariableDeclaration, s: AST<Token>) throws -> VariableDeclaration { (d.body, v...s)  }
            if case .yy0(let v) = yySymbolOnStack(distanceFromTop: 2),
               case .yy1(let d) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy1(try codeBlockForRule55(v: v, d: d, s: s))
            }
        case 56: /* member_list ::= */
            func codeBlockForRule56() throws -> [VariableDeclaration] { []  }
            return .yy9(try codeBlockForRule56())
        case 57: /* member_list ::= member(m) member_list(l) */
            func codeBlockForRule57(m: VariableDeclaration, l: [VariableDeclaration]) throws -> [VariableDeclaration] { [m] + l  }
            if case .yy1(let m) = yySymbolOnStack(distanceFromTop: 1),
               case .yy9(let l) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy9(try codeBlockForRule57(m: m, l: l))
            }
        case 58: /* alternative ::= Identifier(n) tuple(p) */
            func codeBlockForRule58(n: AST<Token>, p: TupleLiteral) throws -> Alternative { ((name: n, payload: p), n...p)  }
            if case .yy0(let n) = yySymbolOnStack(distanceFromTop: 1),
               case .yy48(let p) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy4(try codeBlockForRule58(n: n, p: p))
            }
        case 59: /* alternative ::= Identifier(n) */
            func codeBlockForRule59(n: AST<Token>) throws -> Alternative { ((name: n, payload: ([], .empty)), n.location)  }
            if case .yy0(let n) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy4(try codeBlockForRule59(n: n))
            }
        case 60: /* alternative_list ::= */
            func codeBlockForRule60() throws -> [Alternative] { []  }
            return .yy56(try codeBlockForRule60())
        case 61: /* alternative_list ::= alternative(a) */
            func codeBlockForRule61(a: Alternative) throws -> [Alternative] { [a]  }
            if case .yy4(let a) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy56(try codeBlockForRule61(a: a))
            }
        case 62: /* alternative_list ::= alternative(a) COMMA alternative_list(l) */
            func codeBlockForRule62(a: Alternative, l: [Alternative]) throws -> [Alternative] { [a] + l  }
            if case .yy4(let a) = yySymbolOnStack(distanceFromTop: 2),
               case .yy56(let l) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy56(try codeBlockForRule62(a: a, l: l))
            }
        case 63: /* declaration ::= function_definition(f) */
            func codeBlockForRule63(f: FunctionDefinition) throws -> Declaration { (.function(f), f.location)  }
            if case .yy128(let f) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy87(try codeBlockForRule63(f: f))
            }
        case 64: /* declaration ::= function_declaration(f) */
            func codeBlockForRule64(f: FunctionDefinition) throws -> Declaration { (.function(f), f.location)  }
            if case .yy128(let f) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy87(try codeBlockForRule64(f: f))
            }
        case 65: /* declaration ::= STRUCT(s) Identifier(n) LEFT_CURLY_BRACE member_list(m) RIGHT_CURLY_BRACE(r) */
            func codeBlockForRule65(s: AST<Token>, n: AST<Token>, m: [VariableDeclaration], r: AST<Token>) throws -> Declaration { (.struct(StructDefinition(name: n, members: m)), s...r)  }
            if case .yy0(let s) = yySymbolOnStack(distanceFromTop: 4),
               case .yy0(let n) = yySymbolOnStack(distanceFromTop: 3),
               case .yy9(let m) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy87(try codeBlockForRule65(s: s, n: n, m: m, r: r))
            }
        case 66: /* declaration ::= CHOICE(c) Identifier(n) LEFT_CURLY_BRACE alternative_list(l) RIGHT_CURLY_BRACE(r) */
            func codeBlockForRule66(c: AST<Token>, n: AST<Token>, l: [Alternative], r: AST<Token>) throws -> Declaration { (.choice(name: n, alternatives: l), c...r)  }
            if case .yy0(let c) = yySymbolOnStack(distanceFromTop: 4),
               case .yy0(let n) = yySymbolOnStack(distanceFromTop: 3),
               case .yy56(let l) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy87(try codeBlockForRule66(c: c, n: n, l: l, r: r))
            }
        case 67: /* declaration ::= VAR(v) variable_declaration(d) EQUAL expression(i) SEMICOLON(s) */
            func codeBlockForRule67(v: AST<Token>, d: VariableDeclaration, i: Expression, s: AST<Token>) throws -> Declaration { (.variable(name: d.body.name, type: d.body.type, initializer: i), v...s)  }
            if case .yy0(let v) = yySymbolOnStack(distanceFromTop: 4),
               case .yy1(let d) = yySymbolOnStack(distanceFromTop: 3),
               case .yy97(let i) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy87(try codeBlockForRule67(v: v, d: d, i: i, s: s))
            }
        case 68: /* declaration_list ::= */
            func codeBlockForRule68() throws -> [Declaration] { []  }
            return .yy95(try codeBlockForRule68())
        case 69: /* declaration_list ::= declaration(d) declaration_list(l) */
            func codeBlockForRule69(d: Declaration, l: [Declaration]) throws -> [Declaration] { [d] + l  }
            if case .yy87(let d) = yySymbolOnStack(distanceFromTop: 1),
               case .yy95(let l) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy95(try codeBlockForRule69(d: d, l: l))
            }
        default:
            fatalError("Can't invoke code block for rule number \(ruleNumber) - no such rule")
        }
        fatalError("Can't resolve types correctly for invoking code block for rule number \(ruleNumber)")
    }

    private func yySymbolOnStack(distanceFromTop: Int) -> CitronSymbol {
        assert(yyStack.count > distanceFromTop)
        return yyStack[yyStack.count - 1 - distanceFromTop].symbol
    }

    func yyUnwrapResultFromSymbol(_ symbol: CitronSymbol) -> CitronResult {
        if case .yy95(let result) = symbol {
            return result
        } else {
            fatalError("Unexpected mismatch in result type")
        }
    }

    // Error capturing

    typealias CitronErrorCaptureDelegate = _CarbonParserCitronErrorCaptureDelegate

    weak var errorCaptureDelegate: CitronErrorCaptureDelegate? = nil

    let yyErrorCaptureSymbolNumbersForState: [CitronStateNumber:[CitronSymbolNumber]] = [:]
    let yyCanErrorCapture: Bool = false
    let yyErrorCaptureDirectives: [CitronSymbolNumber:(endAfter:[[CitronTokenCode]],endBefore:[CitronTokenCode])] = [:]
    let yyErrorCaptureEndBeforeTokens: Set<CitronSymbolNumber> = []

    let yyErrorCaptureEndAfterSequenceEndingTokens: Set<CitronSymbolNumber> = []

    func yyShouldSaveErrorForCapturing(error: Error) -> Bool {
        fatalError("This parser was not generated with error capturing information")
    }

    func yyCaptureError(on symbolCode: CitronNonTerminalCode, error: Error, state: CitronErrorCaptureState) -> CitronSymbol? {
        fatalError("This parser was not generated with error capturing information")
    }

    func yySymbolContent(_ symbol: CitronSymbol) -> Any { return symbol.typeErasedContent() }

    let yyStartSymbolNumber: CitronSymbolNumber = 45
    let yyEndStateNumber: CitronStateNumber = 98

    var yyErrorCaptureSavedError: (error: Error, isLexerError: Bool)? = nil
    var yyErrorCaptureTokensSinceError: [(token: CitronToken, tokenCode: CitronTokenCode)] = []
    var yyErrorCaptureStackIndices: [Int] = []
    var yyErrorCaptureStartSymbolStackIndex: Int? = nil

    var numberOfCapturedErrors: Int = 0
}

protocol _CarbonParserCitronErrorCaptureDelegate : class {
    func shouldSaveErrorForCapturing(error: Error) -> Bool
}

extension _CarbonParserCitronErrorCaptureDelegate {
    func shouldSaveErrorForCapturing(error: Error) -> Bool {
        return true
    }
}

// Ability to use == to compare CitronSymbolCode with CitronTokenCode / CitronNonTerminalCode

extension CarbonParser.CitronSymbolCode {
    static func == (a: CarbonParser.CitronSymbolCode, b: CarbonParser.CitronTokenCode) -> Bool {
        guard case let .token(code) = a else { return false }
        return (code == b)
    }
    static func == (a: CarbonParser.CitronTokenCode, b: CarbonParser.CitronSymbolCode) -> Bool {
        guard case let .token(code) = b else { return false }
        return (code == a)
    }
    static func == (a: CarbonParser.CitronSymbolCode, b: CarbonParser.CitronNonTerminalCode) -> Bool {
        guard case let .nonterminal(code) = a else { return false }
        return (code == b)
    }
    static func == (a: CarbonParser.CitronNonTerminalCode, b: CarbonParser.CitronSymbolCode) -> Bool {
        guard case let .nonterminal(code) = b else { return false }
        return (code == a)
    }
}

// Ability to use switch (symbolCode) { case .tokenCode: ...; case .nonterminalCode: ... }

extension CarbonParser.CitronSymbolCode {
    static func ~= (pattern: CarbonParser.CitronTokenCode, value: CarbonParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
    static func ~= (pattern: CarbonParser.CitronNonTerminalCode, value: CarbonParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
}
